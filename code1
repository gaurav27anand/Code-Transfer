import csv

def analyze_build_data(input_file_path, output_file_path):
    csv_rows = []
    long_waits = []  # Track builds with long queue times

    with open(input_file_path, 'r') as file:
        reader = csv.reader(file)
        header = next(reader)  # Get the header row

        # Dynamically create the output header
        output_header = ['BuildNumber', 'TotalBuildTime', 'LongWaitBetweenBuilds']
        stage_count = (len(header) - 1) // 2  # Determine how many stages there are based on the columns
        for i in range(1, stage_count + 1):
            output_header.append(f'Stage{i}_Duration')
            output_header.append(f'Stage{i}_Status')
        csv_rows.append(output_header)

        previous_build_end_time = None  # To calculate the time gap between builds

        # Process each build in the CSV
        for row in reader:
            build_number = row[0]
            total_build_time = 0
            build_data = [build_number]  # Start building the output row with the build number

            # Process all stages
            for i in range(1, len(row), 2):  # Process duration/status pairs
                stage_duration = int(row[i]) if row[i].isdigit() else 0
                stage_status = row[i + 1]

                total_build_time += stage_duration
                build_data.append(stage_duration)
                build_data.append(stage_status)

            # Check for long gaps between builds (if previous end time exists)
            if previous_build_end_time is not None:
                time_gap = int(build_number) - previous_build_end_time
                if time_gap > 600000:  # Example threshold of 10 minutes in ms
                    long_wait = time_gap / 1000  # Convert ms to seconds
                else:
                    long_wait = ''
            else:
                long_wait = ''  # No gap for the first build

            # Update previous build end time for the next iteration
            previous_build_end_time = int(build_number) + total_build_time

            # Append the total build time and the long wait detection to the build data
            build_data.insert(1, total_build_time)  # Insert total build time after build number
            build_data.insert(2, long_wait)  # Insert long wait after total build time

            csv_rows.append(build_data)

    # Write the processed data to a new CSV file
    with open(output_file_path, 'w', newline='') as outfile:
        writer = csv.writer(outfile)
        writer.writerows(csv_rows)

    print(f"Analysis written to {output_file_path}")

# Call the analysis function
analyze_build_data('jenkins_build_data.csv', 'jenkins_optimized_analysis.csv')
